<?phprequire_once "CodonOpt_Controller_ViewResultSummary_Ancestor.php";require_once "CodonOpt_Controller_Setup_Sequence_Ancestor.php";require_once "CodonOpt_DAO_user_results.php";require_once "CodonOpt_Utility.php";//This class is used to validate and generate new User Result objects for the table//It is used for the add/delete User defined Sequence, and for the original DNA sequence (if any) on first loadclass CodonOpt_Controller_ViewResultSummaryInsertNewResult extends CodonOpt_Controller_ViewResultSummary_Ancestor {	//Input Sequence Max Length, is 3x the base input sequence	public static function getInputSequenceMaxLength() {		return ( 3 * CodonOpt_Controller_Setup_Sequence_Ancestor::getInputSequenceMaxLength() );	}		//Title Max Length	private static $TitleMaxLength = 20;	public static function getTitleMaxLength() 	{ return CodonOpt_Controller_ViewResultSummaryInsertNewResult::$TitleMaxLength; }		//Whether to allow adding new sequences	private static $MaxUserDefinedSeqCount = 10;	//Maximum number of UDS	public static function getMaxUserDefinedSeqCount()	{ return CodonOpt_Controller_ViewResultSummaryInsertNewResult::$MaxUserDefinedSeqCount; }	public function allowNewSequence() {		//Limit to 10 User Defined Sequences		return ($this->getCurrentRowCount() < CodonOpt_Controller_ViewResultSummaryInsertNewResult::$MaxUserDefinedSeqCount);	}		//Input Sequence	private $InputSequence = null;	public function setInputSequence($input) {		if ( isset($input) ) {			$this->InputSequence = $input;		}	}	public function getInputSequence() {		return $this->InputSequence;	}	//Cleaned input convert to upper case and without spaces/tabs/linebreaks/underscores etc	protected $CleanedInput = null;	protected function getCleanedInput() {		return $this->CleanedInput;	}		//Title	private $Title = null;	public function setTitle($input) {		if ( isset($input) ) {			$this->Title = $input;		}	}	public function getTitle() {		return $this->Title;	}		//Error Messages	private $InputSequenceErrorMsg = null;	private $TitleErrorMsg = null;	//Error Messages have Getters only	public function getInputSequenceErrorMsg() {		return $this->InputSequenceErrorMsg;	}	public function getTitleErrorMsg() {		return $this->TitleErrorMsg;	}		//Constructor Takes in Current Job, and uses it to instantiate Jobs Controller	private $UserInsert;			//Whether this is a user insert is set at construction and never changes	public function CodonOpt_Controller_ViewResultSummaryInsertNewResult(		$InputJob,		$IsUserInsert				//Is this job a user insert?	) {		parent::__construct($InputJob);	//Parent calls job		$this->UserInsert = (bool)$IsUserInsert;	}		//Check the inputs are correct, and if they are, submit them	//If submission was successful, return true, otherwise return false	public function validateGenerateNewUserResult() {		$FailCount = 0;	//Count number of validation failures		//The other checks are in self-contained subfunctions		if (! $this->IsValidInputSequence() )	{$FailCount++;}	//Check Input Sequence		if (! $this->IsValidTitle() )			{$FailCount++;}	//Check Title		if ($this->UserInsert) {								//If this is User Inserted			if (! $this->CheckCleanedInputForDuplicates() )		//Then Check for duplicates			{$FailCount++;}			if (! $this->allowNewSequence() )	{$FailCount++;}	//And Check if allowing new sequence		}				//Before proceeding, all CheckList must be true		if ($FailCount == 0) {	//If there are no false, commence generation of user results			return( $this->generateNewUserResult() );		} else {			return null;		}	}		//Check there is valid input sequence	private function IsValidInputSequence() {		if ( isset($this->InputSequence) ) {				//If there is input sequence			$this->CleanedInput = CodonOpt_Utility::CleanSequence($this->InputSequence);			if ( $this->CleanedInput == "" ) {				//If Cleaned sequence is empty				$this->InputSequenceErrorMsg = "Please enter some input sequence!";				return false;								//Input Sequence not valid			} else {										//Otherwise there is some Cleaned Sequence				if ( strlen($this->CleanedInput)			//Check Length is within limit					<= CodonOpt_Controller_ViewResultSummaryInsertNewResult::getInputSequenceMaxLength()				) {											//Check sequence as Nucleotides					return $this->CheckCleanedInputAsNucleotide();				} else {									//Otherwise Length exceeds limits					$this->InputSequenceErrorMsg = "Input Sequence Too Long. Please reduce it to ".CodonOpt_Controller_ViewResultSummaryInsertNewResult::getInputSequenceMaxLength()." characters or less";					return false;				}			}		} else {			//Otherwise there is no input sequence			return false;	//Return false			//No error messages as this is likely first load		}		return false;	}		//Check the input sequence as Nucleotide	//Due to the complexity of nucleotide checking operations it is divided into 2 parts	//This first part checks for general characteristics (No invalid bases, length divisible by 3)	private function CheckCleanedInputAsNucleotide() {		$ATUCG = array ("A","T","U","C","G");		$ATCG = array ("A","T","C","G");		$AUCG = array ("A","U","C","G");		$tempCopy = $this->CleanedInput;		$tempCopy = 							//Ensure no invalid characters			str_ireplace($ATUCG,"",$tempCopy);		if ($tempCopy == "") {					//If nothing is left, it is correct			$tempCopyU = $this->CleanedInput;	//Remove U			$tempCopyU = str_ireplace($AUCG, "", $tempCopyU);				$tempCopyT = $this->CleanedInput;	//Remove T			$tempCopyT = str_ireplace($ATCG, "", $tempCopyT);			;;;;;;if ($tempCopyU == "") {		//If sequence is RNA (only U present)				$DNAstandardizer = 				//Convert to Cleaned Input to DNA for saving					CodonOpt_Controller_ViewResult_Ancestor::getNucleotideStandardizer();				$this->CleanedInput = $DNAstandardizer->standardize($this->CleanedInput);				return 							//Check Translation					$this->CheckCleanedInputLength();			} elseif ($tempCopyT == "") {		//Otherwise If sequence is DNA (only T present)				return 							//Check Length					$this->CheckCleanedInputLength();			} else {							//Otherwise neither DNA or RNA (both T and U present)				$this->InputSequenceErrorMsg = "Both 'T' (for DNA) and 'U' (for RNA) bases detected. Please use only one or the other.";				return false;						}		} else {											//Otherwise, non-protein character found			$this->InputSequenceErrorMsg = "DNA/RNA sequence should only contain unambiguous nucleotide bases (".implode(", ",$ATUCG).").";			return false;		}	}		//This is the 2nd nucleotide checking function	//Checks that Cleaned Input has correct length	private function CheckCleanedInputLength() {		$seqlength = strlen($this->CleanedInput);	//Extract length		$ErrorMsg = "";								//Error Message		if ( ($seqlength%3) == 0 ) {				//If string is divisible by 3, run start/stop checks			//Ensure Length Matches			$TargetLength = 0;			if ( 									//If Input is protein				$this->getCurrentJob()->getIs_input_protein() 			) {				$proteinlength = strlen( $this->getCurrentJob()->getInput_sequence() );				$TargetLength = ( 					//Length is the same as input					($proteinlength + 1)			//Add 1 for stop codon 					*3								//multiply by 3				);				$ErrorMsg = "Whereas input protein sequence has ".$proteinlength." amino acids giving target length of ".$TargetLength." (including stop codon)";			} else {								//Otherwise Input is nucleotide				$TargetLength = 					//Length is the same as input					strlen( $this->getCurrentJob()->getInput_sequence() );				$ErrorMsg = "Whereas input nucleotide sequence has ".$TargetLength." bases (including stop codon)";			}			if (									//If target length matches				strlen($this->CleanedInput) == $TargetLength			) {										//Check translation				return $this->CheckCleanedInputTranslation();			} else {								//Otherwise target length does not match				$this->InputSequenceErrorMsg = "Current sequence is ".$seqlength." bases long. ".$ErrorMsg;				return false;			}					} else {			$this->InputSequenceErrorMsg = "Current sequence is ".$seqlength." bases long. DNA/RNA sequence length should be divisible by 3.";			return false;			}	}		//This is the 3rd nucleotide checking function	//Checks that the Cleaned Input Translates to the same sequence as output	private $InputStopHash;								//Hash to store stop codons	private function CheckCleanedInputTranslation() {			//Translate Input Sequence into Protein			$RNAstandardizer = 								//Convert to Cleaned Input to RNA for translation			new	CodonOpt_StandardizeNucleotide_RNA();		$DNAstandardizer = 								//Convert to Cleaned Input to DNA for saving			new	CodonOpt_StandardizeNucleotide_DNA();		$CodonList = str_split(							//Break into sets of triplets			$RNAstandardizer->standardize($this->CleanedInput) , 3		);		$CodonHash = $this->getTranslationRules()->getCodonHash();		$this->InputStopHash = array();		foreach ($CodonHash as $tempKey=>$tempValue) {			if ($tempValue == "*") {					//If Base is stop				$this->InputStopHash[					//Store it in Stop Hash as DNA					$DNAstandardizer->standardize( $tempKey )				] = $DNAstandardizer->standardize( $tempKey );						}		}		$AAList = array();		foreach ($CodonList as $Codon) {			$aaBase=$CodonHash[$Codon];					//Extract amino acid			if ( isset($aaBase) ) {						//If Amino acid found				array_push($AAList, $aaBase);			//Add it to list			} else {				die ("Error: Input Sequence Translation, Amino Acid not found for: ".$Codon);			}		}		$InputAsProtein = implode($AAList,"");			//Store in this variable				//Translate Original into Protein		$OriginalAsProtein = "";						//Find the original as protein		if (											//If original Input was protein			$this->getCurrentJob()->getIs_input_protein()		) {												//Then just save directly, with stop codon			$OriginalAsProtein = $this->getCurrentJob()->getInput_sequence()."*";		} else {										//Otherwise original input was not protein			$TransRule = 								//Retrieve User selected Translation code.				CodonOpt_DAO_translationrules::selectByNCBIcode(					$this->getCurrentJob()->getNucleotide_input_translation_rule() 				);			if ( isset($TransRule) ) {				$CodonHash = $TransRule->getCodonHash();//Get Codon Hash				$CodonList = str_split( 				//Break into sets of triplets					$RNAstandardizer->standardize( $this->getCurrentJob()->getInput_sequence() ),					3 				);				$AAList = array();				foreach ($CodonList as $Codon) {					$aaBase=$CodonHash[$Codon];			//Extract amino acid					if ( isset($aaBase) ) {				//If Amino acid found						array_push($AAList, $aaBase);	//Add it to list					} else {						die ("Error: Original Sequence Translation, Amino Acid not found for: ".$Codon);					}				}				$OriginalAsProtein = implode($AAList,"");//Store in this variable			} else {				$this->InputSequenceErrorMsg = "Invalid Translation Ruleset or Database connection error.";				return false;			}		}		//echo $OriginalAsProtein."<br/>";		//echo $InputAsProtein."<br/>";		if ($InputAsProtein == $OriginalAsProtein) {	//If sequences match Check for Duplicates			return true;		} else {										//Otherwise sequences do not match			$this->InputSequenceErrorMsg = "Input sequence does not code for the same original protein.";			return false;		}	}		//This is the 4th nucleotide checking function	//Checks that the Cleaned Input is not already present amongst existing sequences	private function CheckCleanedInputForDuplicates() {		$ResultList = 								//Get all current output sequences from DB			CodonOpt_DAO_user_results::selectFastAndOutputByEncryptExampleId( $this->getCurrentJob()->getEncrypt_Id(), $this->getCurrentJob()->getExample_serial() );		foreach ($ResultList as $Num=>$Result) {	//Go through each result			if ( 									//If it is duplicate				$Result->getOutput_sequence() == $this->CleanedInput			) {				$this->InputSequenceErrorMsg =  	//Generate Error message					"Input sequence is a duplicate of ";				if ( $Result->getUser_insert() ) {	//If this is user inserted					$DisplayName = $Result->getUser_given_title();					if (							//If Name is too long						strlen($DisplayName) >= 25 					) {								//Trim and add "..." at end						$DisplayName = substr( $DisplayName ,0,25 )."...";					}					$this->InputSequenceErrorMsg .=	//Add Name						"User Defined Sequence: ".$DisplayName;				} else {							//Otherwise this is not user insert					$this->InputSequenceErrorMsg .=	//Show Display ID						"Optimized Sequence ".$Result->getDisplay_id();				}				return false;						//Sequence fails			}		}		return true;								//If it reaches here, none of them are duplicates	}		//Check there is valid input Title	private function IsValidTitle() {		if ( isset($this->Title) ) {				//Ensure there is Title field			if ($this->Title == "") {				//If there is NO Title				return true;						//Return true as Title is optional			} else {								//Otherwise there is Title				$titleCopy = CodonOpt_Utility::CleanSequence($this->Title);				$titleCopy = str_ireplace(			//Remove AlphaNumeric					CodonOpt_Utility::GetAlphaNumeric(),						"",$titleCopy				);				$titleCopy = str_ireplace(			//Remove Symbols					CodonOpt_Utility::getAllowedTitleSymbols(),					"",$titleCopy				);				if ( strlen($titleCopy) >= 1 ) {	//If there are any characters remaining					$this->TitleErrorMsg = "Title can only contain alpha-numeric characters, spaces, and the following symbols: ".implode( " ",CodonOpt_Utility::getAllowedTitleSymbols() );					return false;					//Display Error Message				} else {							//Otherwise there are no characters remaining					if ( strlen($this->Title)		//Check Length is within limit						<= CodonOpt_Controller_ViewResultSummaryInsertNewResult::$TitleMaxLength					) {							return true;				//return true if it is					} else {						//Otherwise Length exceeds limits						$this->TitleErrorMsg = "Input Title Too Long. Please reduce it to ".CodonOpt_Controller_ViewResultSummaryInsertNewResult::$TitleMaxLength." characters or less";						return false;					}				}			}		} else {									//If no email Title			return false;							//Likely first load, do not run		}	}		//This function carries out submission of data 	private function generateNewUserResult() {		$UserResult = CodonOpt_DTO_user_results::CreateNewUserResultObject(			$this->getCurrentJob()->getSerial(),	//$input_job_serial			$this->UserInsert,						//$input_user_insert			$this->Title,							//$input_given_title			$this->CleanedInput						//$output_sequence		);		//Seed Colour Pickers		if (	$this->								//If maximize/minimize by IC					showOptimizationParameter( $this->getOptimize_ic() ) ||					$this->								//OR by CAI					showOptimizationParameter( $this->getOptimize_cai() )			) {			$this->getIc_ColorPicker()->			//Get Color Picker				CountOptSeqCodonUsage($this->CleanedInput);		}		if ( $this->								//If maximize/minimize by CC				showOptimizationParameter( $this->getOptimize_cc() ) 		) {			$this->getCc_ColorPicker()->			//Get Color Picker				CountOptSeqCodonUsage($this->CleanedInput);		}				//Calculate IC Fitness Value		if ( $this->showOptimizationParameter( $this->getOptimize_ic() ) ) {			$ICValue = 									//Calculate Distance Value				$this->Calculate_IC_CC_Positive( $this->getIc_ColorPicker()->getFilteredCodonHash() );			//Modify and Save Value according to optimization mode			;;;;;;if ($this->getOptimize_ic() == 1) {	//If Maximize				$UserResult->setIc_fitness(0-$ICValue);	//Fitness is negative Distance			} elseif ($this->getOptimize_ic() == 2) {	//If Minimize				$UserResult->setIc_fitness(0-$ICValue);	//Fitness is negative Distance			} else {				die("Optimize_ic is neither 1 nor 2");			}		}				//Calculate CC Fitness Value		if ( $this->showOptimizationParameter( $this->getOptimize_cc() ) ) {			$CCValue = 									//Calculate Distance Value				$this->Calculate_IC_CC_Positive( $this->getCc_ColorPicker()->getFilteredCodonHash() );			//Modify and Save Value according to optimization mode			;;;;;;if ($this->getOptimize_cc() == 1) {	//If Maximize				$UserResult->setCc_fitness(0-$CCValue);	//Fitness is negative Distance			} elseif ($this->getOptimize_cc() == 2) {	//If Minimize				$UserResult->setCc_fitness(0-$CCValue);	//Fitness is negative Distance			} else {				die("Optimize_cc is neither 1 nor 2");			}		}				//Calculate CAI Fitness Values		if ( $this->showOptimizationParameter( $this->getOptimize_cai() ) ) {			$MaxSynonCodonHash = array();			$CodonHash = $this->getIc_ColorPicker()->getFilteredCodonHash();			foreach ($CodonHash as $tempKey=>$tempCodon) {	//For each Codon				$aaBase = $tempCodon->getAAbase();			//Extract amino acid				if (! isset($MaxSynonCodonHash[$aaBase]) ) {//If this base is not defined					$MaxSynonCodonHash[$aaBase] = 0;		//Then define it				}				$HostFreq = $tempCodon->getHostRelFreq();	//Extract frequenct				if (										//If Frequency is larger than current value					$MaxSynonCodonHash[$aaBase] < $HostFreq				) {					$MaxSynonCodonHash[$aaBase] = $HostFreq;//Overwrite current value				}			}			$CAIValue = 0;						//Calculate Distance Value			$CodonList =						//Break into sets of triplets				str_split( $this->CleanedInput , 3 );			foreach ($CodonList as $Codon) {	//For Each Codon				$aaBase = 						//Extract Base					$CodonHash[$Codon]->getAAbase();				$HostFreq =						//Extract this Frequency					$CodonHash[$Codon]->getHostRelFreq();				$MaxFreq = 						//Extract Max Frequency					$MaxSynonCodonHash[$aaBase];				$CAIValue += 					//Multiply into CAIValue					log($HostFreq/$MaxFreq);				}			$CAIValue = 						//Average				$CAIValue / count($CodonList);			$CAIValue = exp($CAIValue);			//Exponential			//Modify and Save Value according to optimization mode			;;;;;;if ($this->getOptimize_cai() == 1) {	//If Maximize				$UserResult->							//Fitness is positive					setCai_fitness($CAIValue);								} elseif ($this->getOptimize_cai() == 2) {	//If Minimize				$UserResult->							//Fitness is positive					setCai_fitness($CAIValue);			} else {				die("Optimize_cai is neither 1 nor 2");			}		}				//Count Number of Hidden Stop Codons		if ( $this->showOptimizationParameter( $this->getOptimize_hidden_stop_codon() ) ) {			$HSCseq = strtolower($this->CleanedInput);			$ScanArray = str_split($HSCseq);		//Array to scan			$MarkArray = str_split($HSCseq);		//Array to mark upper case			$HSCcount = 0;							//Numbers of HSC found			$MaxLength = count($ScanArray);			//Get Length			for ($numA = 0; $numA<($MaxLength-3); $numA++) {				if ( ($numA%3) != 0) {				//Skip normal reading frame codons					$ScanString = 					//Put together Scan String						strtoupper(							$ScanArray[$numA  ].							$ScanArray[$numA+1].							$ScanArray[$numA+2]					);					if (							//If Scan string is a stop codon						isset( $this->InputStopHash[$ScanString] )					) {								//Mark as upper case in MarkArray						$MarkArray[$numA  ] = strtoupper( $MarkArray[$numA  ] );						$MarkArray[$numA+1] = strtoupper( $MarkArray[$numA+1] );						$MarkArray[$numA+2] = strtoupper( $MarkArray[$numA+2] );						$HSCcount++;				//Add 1 to number of HSC found					}				}			}			$HSCseq = implode("",$MarkArray);		//Combine array into sequence			$UserResult->setOutput_sequence_hidden_stop_codon($HSCseq);			$UserResult->setNumber_of_stop_codon_motifs($HSCcount);		}				//Calculate GC Fitness		if ( $this->showGC_target() ) {			$GC_content = 							//Count number of GC bases				CodonOpt_Utility::count_GC_content( $this->CleanedInput );			$TargetGC = 							//Subtract target value and modulus negative				$this->getCurrentJob()->getOptimize_gc_target() / 100;			$GC_Fitness = 0;						//Fitness is always negative			if ($GC_content > $TargetGC) {			//If Target is smaller				$GC_Fitness = $TargetGC - $GC_content;			} else {								//If Target is larger				$GC_Fitness = $GC_content - $TargetGC;			}										//Save the Fitness			$UserResult->setGc_content_fitness($GC_Fitness);		}				//Count and Highlight Exclusion Sequences		if ( $this->showExclusionReport() ) {			$ExclusionFitnessArray = array();	//Array of exclusion fitness			$ExclusionOutSeq = strtolower($this->CleanedInput);			$MarkArray = str_split($ExclusionOutSeq);			$ScanArray = str_split($ExclusionOutSeq);			$MaxLength = count($ScanArray);			$DNAstandardizer = 					//Convert Exclusion to DNA for presentation				new	CodonOpt_StandardizeNucleotide_DNA();			$ExclusionList = 					//Extract list of exclusion sequences				explode(",", strtoupper( $this->getCurrentJob()->getExclusion_sequence() ) );			foreach (							//For each exclusion sequence				$ExclusionList as $AmbigExclSeq			) {					$ExclCount = 0;					//Counter for number of occurences				$DNAAmbigExclSeq =				//Convert to DNA					strtolower( $DNAstandardizer->standardize($AmbigExclSeq) );				$DNAExclList =					//Get list of unambiguous sequences					CodonOpt_Utility::convertAmbigDNAToAllUnambig($DNAAmbigExclSeq);				$ExclLength = strlen($DNAAmbigExclSeq);		//(Handle seperately to manage varying exclusion lengths)				for ($numA=0; $numA<($MaxLength-$ExclLength+1); $numA++) {					$ScanString = ""; 						//Put together Scan String					for ($numB=0; $numB<$ExclLength; $numB++) {						$ScanString .= $ScanArray[$numA+$numB];					}					foreach ($DNAExclList as $DNAExclSeq) {	//For each unambiguous sequence						if (								//If Scan string matches target							$ScanString == $DNAExclSeq						) {									//Mark as upper case in MarkArray							for ($numB=0; $numB<$ExclLength; $numB++) {								$MarkArray[$numA+$numB]		//Mark the occurence in the Mark Array									= strtoupper( $MarkArray[$numA+$numB] );							}							$ExclCount++;					//Add to occurence count						}					}				}				$ExclusionFitnessArray[$DNAAmbigExclSeq]	//Save Number of times this seq was found to array					= $ExclCount;			}			$ExclusionFitness = "";					//Concat Arrays into strings						foreach ($ExclusionFitnessArray as $ExSeq=>$ExSeqCount) {				$ExclusionFitness .= $ExSeq.":".$ExSeqCount.";";			}										//Save the fitness and the sequence			$ExclusionOutSeq = 						//Collapse output sequence array into string				implode("",$MarkArray);			$UserResult->setExclusion_fitness($ExclusionFitness);			$UserResult->setOutput_sequence_exclusion($ExclusionOutSeq);		}				//Highlight Consecutive Repeat Sequences		if ( $this->showRepeat_consec_report() ) {			$RepLength = $this->getCurrentJob()->getRepeat_consec_length();			$RepCount = $this->getCurrentJob()->getRepeat_consec_count();			$RepeatOutSeq = strtolower($this->CleanedInput);			//$pattern = "/(.{3}){3}/";			//preg_match($pattern, $this->CleanedInput, $matches, PREG_OFFSET_CAPTURE);			//print_r($matches);			$ScanArray = str_split($RepeatOutSeq);			$MarkArray = str_split($RepeatOutSeq);			$MaxLength = count($ScanArray);			$RunLength = $MaxLength - ($RepLength*$RepCount) + 1;			for ($numA=0; $numA<$RunLength; $numA++) {			//For Each Base				$SeedArray = array();							//Compile Seed Array				for ($numB=0; $numB<$RepCount; $numB++) {		//Each cell in seed is one motif					$SeedArray[$numB] = "";						//Initiate cell					for ($numC=0; $numC<$RepLength; $numC++) {	//Each motif covers the motif length						$SeedArray[$numB] .= 							$ScanArray[ $numA + ($numB*$RepLength) + $numC ];					}				}				$FailCount = 0; 								//Check if there are any mismatches				for ($numB=0; $numB<($RepCount-1); $numB++) {	//Go through the seed array					if (										//If the elements are different						$SeedArray[$numB] != $SeedArray[$numB+1]					) {							$FailCount++;							//Add to fail count					}				}				if ($FailCount == 0) {							//If there are no failures					for (										//This is a repeat						$numB=0; $numB<($RepCount*$RepLength); $numB++					) {											//Mark on the Mark Array						$MarkArray[$numA+$numB] = strtoupper($MarkArray[$numA+$numB]);					}				}			}			$RepeatOutSeq = implode("",$MarkArray);				//Save the Results			$UserResult->setOutput_sequence_repeat_consec($RepeatOutSeq);		}						//Highlight Allmotif Repeat Sequences		if ( $this->showRepeat_allmotif_report() ) {			$repAllmotifLen = $this->getCurrentJob()->getRepeat_allmotif_length();			$repAllmotifCount = $this->getCurrentJob()->getRepeat_allmotif_count();			$RepeatOutSeq = strtolower($this->CleanedInput);			$tempDnaArray = str_split( strtolower($this->CleanedInput) );			$tempFlagArray = str_split( strtolower($this->CleanedInput) );			$SeqLength = strlen($this->CleanedInput);			$totalAllmotifCount = 0;			$motifHash_all = array();			$motifHash_flag = array();			#Example 10 bases would be 0-9			#Assuming the $repAllmotifLen is 5, it would run as			#	0-4 , 1-5 , 2-6 , 3-7 , 4-8 , 5-9			#So highest value of numA would be: $SeqLength - $repAllmotifLen = 10 - 5 = 5			#To reach this highest value, condition check would be: $numA<=$SeqLength-$repAllmotifLen			for ($numA=0; $numA<=$SeqLength-$repAllmotifLen; $numA++) {				$tempString = "";				for ($numB=0; $numB<$repAllmotifLen; $numB++) {					$tempString .= $tempDnaArray[$numA+$numB];				}				if ( isset( $motifHash_all[$tempString] ) ) {		#If number already present					$motifHash_all[$tempString]++;					#Add to number				} else {											#Otherwise number not yet present					$motifHash_all[$tempString] = 1;				#Define number				}			}			#Find which motifs break limit and transfer them to $motifHash_flag			foreach ($motifHash_all as $tempMotif => $tempCount) {	#Go through al motifs				if ($tempCount >= $repAllmotifCount) {				#If count exceeds limit					$motifHash_flag[$tempMotif] = $tempCount;		#Store in flag hash					$totalAllmotifCount += $tempCount - $repAllmotifCount + 1;				}			}						#Go through entire sequence again and flag motifs			for ($numA=0; $numA<=$SeqLength-$repAllmotifLen; $numA++) {				$tempString = "";				for ($numB=0; $numB<$repAllmotifLen; $numB++) {					$tempString .= $tempDnaArray[$numA+$numB];				}				if ( isset( $motifHash_flag[$tempString] ) ) {		#If motif is found in flag hash					for ($numB=0; $numB<$repAllmotifLen; $numB++) {	#Flag by making it upper case						$tempFlagArray[$numA+$numB] = strtoupper( $tempFlagArray[$numA+$numB] );					}				}			}			$UserResult->setOutput_sequence_repeat_allmotif( implode("",$tempFlagArray) );		}		//Finally		return $UserResult;										//Return User Results	}		private function Calculate_IC_CC_Positive($CodonHash) {		$SumDifference = 0;		$TotalCodons = 0;		foreach ($CodonHash as $Codon) {			$HostFreq = $Codon->getHostRelFreq();			$OptFreq = $Codon->getOptSeqRelFreq();			if ($HostFreq > $OptFreq) {				$SumDifference += ($HostFreq-$OptFreq);			} else {				$SumDifference += ($OptFreq-$HostFreq);			}			$TotalCodons++;		}		return ($SumDifference/$TotalCodons);	}}?>