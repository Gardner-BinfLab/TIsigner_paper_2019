<?phprequire_once "CodonOpt_Controller_Setup_Ancestor.php";require_once "CodonOpt_ParseFasta_Codon.php";require_once "CodonOpt_ParseFasta_CodonPair.php";//A simple utlity to check that a text file is valid, and extract content//It takes the form of an object, that accepts the file as part of its constructorclass CodonOpt_Controller_SetupUploadFasta extends CodonOpt_Controller_Setup_Ancestor {	//Whatever limit you set here, remember to update php.ini	//	post_max_size=	//	upload_max_filesize = 	//Also, for very large files the process may take very long	//	max_execution_time	private static $FileSizeLimit = 64;	public static function getFileSizeLimitInMB() {		return CodonOpt_Controller_SetupUploadFasta::$FileSizeLimit;	}	public static function getFileSizeLimitInBytes() {		return (CodonOpt_Controller_SetupUploadFasta::$FileSizeLimit*1048576);	}		private static $MinCodon = 1;	private static $MinCodonPair = 0;	private static $MaxSequenceLength = 300000;	//Maximium length of nucleotide		//Internal Attributes and their getters (no setters, read only)		private $ParseSuccess = false;		//Whether Parsing was successful	public function getParseSuccess() { return $this->ParseSuccess; }	private $ErrorMessage = "";			//Error Message, if any	public function getErrorMessage() { return $this->ErrorMessage; }	private $FileSizeInBytes = 0;		//File Size if successfully parsed	public function getFileSize() { return $this->FileSizeInBytes; }			//Codon Hashes	private $ParseFasta_Codon;	public function getParseFasta_Codon() { return $this->ParseFasta_Codon; }	private $ParseFasta_CodonPair;	public function getParseFasta_CodonPair() { return $this->ParseFasta_CodonPair; }			//Constructor	public function CodonOpt_Controller_SetupUploadFasta() {		parent::__construct();			//Parent extracts job		$this->ParseFasta_Codon = new CodonOpt_ParseFasta_Codon();		$this->ParseFasta_CodonPair = new CodonOpt_ParseFasta_CodonPair();	}			//Check File Upload	public function ParseFastaUpload($InputFileObject) {		if ( isset($InputFileObject) ) {				//If there is file object			if ($InputFileObject["name"] == "") {		//And it does not have an empty name				$this->ErrorMessage = "No file selected. Please select a valid fasta file.";			} else {									//Otherwise name is not empty				$ErrorCode = $InputFileObject["error"];				if ($ErrorCode == 0) {					//If there were no upload errors					$this->FileSizeInBytes = $InputFileObject["size"];	//Save File size					if ( 												//If File Size within limits						$this->FileSizeInBytes < $this::getFileSizeLimitInBytes()					) {						$FileName = $InputFileObject["tmp_name"];		//Extract File Name						if ( file_exists($FileName) ) {					//Check that file is present							$this->ParseSuccess = true;					//Successfully parsed							$this->ErrorMessage = "";							$FileRead = fopen($FileName,"r");							while( ! feof($FileRead) ) {				//Save contents of file to results.								$CurrLine = fgets($FileRead);				//Take current line and remove linebreaks								$CurrLine = str_replace("\r","",$CurrLine);								$CurrLine = str_replace("\n","",$CurrLine);								if ( $this->ProcessLine($CurrLine) ) {	//If line was processed								} else {								//Otherwise line had error									$this->ParseSuccess = false;		//Return False									return false;								}							}							fclose($FileRead);							$this->ProcessLine(">");		//Process Last Line						} else {							$this->ParseSuccess = false;							$this->ErrorMessage = "File was not found at expected location: ".$FileName;										}												} else {								//Otherwise file sie exceeds limits						$this->ParseSuccess = false;						$this->ErrorMessage = "Uploaded file cannot be larger than ".$this::getFileSizeLimitInMB()." megabytes";					}								} else {									//Otherwise there were upload errors					$this->ParseSuccess = false;					switch ($ErrorCode) {						case 1:							$this->ErrorMessage = "Selected File Size exceeds PHP limits";							break;						default:							$this->ErrorMessage = "Upload Error Code: ".$ErrorCode;							break;					}								}						}		} else {			$this->ErrorMessage = "No File Found. Please select a valid fasta file.";		}		$this->CheckAndSave();	}			//This function reads in Fasta from Text area	//To be implemented		//Process Lines	private $CurrentSequenceName = "";	private $CurrentSequence = "";	private function ProcessLine($InputLine) {		if ( substr($InputLine,0,1) == ">" ) {	//If this is start line of next sequence			//Process previous sequence			if (strlen($this->CurrentSequence) <= $this::$MaxSequenceLength) {				$this->ParseFasta_Codon->CountCodonUsageInSequence( $this->CurrentSequence );				$this->ParseFasta_CodonPair->CountCodonUsageInSequence( $this->CurrentSequence );			} else {				$this->ErrorMessage = "Protein coding nucleotide sequence should not exceed ".$this::$MaxSequenceLength." bases long.";				return false;			}			$this->CurrentSequence = "";		//reset sequence			$this->CurrentSequenceName = $InputLine;	//Save new sequence name		} else {								//Otherwise this line is part of current sequence			$MaxLength = strlen($InputLine);			for($num=0; $num<$MaxLength; $num++) {				$Char = substr($InputLine,$num,1);				switch ($Char) {				//Only add in ATUCG material					case "A":					case "a":					case "T":					case "t":					case "U":					case "u":					case "C":					case "c":					case "G":					case "g":						$this->CurrentSequence .= $Char;						break;				}			}		}		return true;	}			//Check if results are valid, and if they are, Save and Continue		private function CheckAndSave() {		if ($this->ParseSuccess) {	//If successfully parsed			$CodonCount = 0;		//Check number of codons			foreach ($this->ParseFasta_Codon->getCodonHash() as $tempCodon=>$tempCount) {				if ($tempCount >= 1) {					$CodonCount++;				}			}			if ($CodonCount < $this::$MinCodon) {	//If fail criterie				$this->ParseSuccess = false;				if ($this::$MinCodon <= 1) {		//Check criteria: if 1 or less, then no valid sequence					$this->ErrorMessage = "No valid sequence was found in file.";				} else {							//If 1 or more, then not enough sequence					$this->ErrorMessage = "File had ".$CodonCount." codons, at least ".$this::$MinCodon." required.";				}				return false;			}			$CodonPairCount = 0;						foreach ($this->ParseFasta_CodonPair->getCodonHash() as $tempCodon=>$tempCount) {				if ($tempCount >= 1) {					$CodonPairCount++;				}			}			if ($CodonPairCount < $this::$MinCodonPair) {				$this->ParseSuccess = false;				$this->ErrorMessage = "File had ".$CodonPairCount." codon pairs, at least ".$this::$MinCodonPair." required.";				return false;			}						$this->SaveAndContinue();		}	}			//Save and return to setup optimization	private function SaveAndContinue() {		//Save Strings		{	//If no IC frequency save null instead of empty string			$nullableSequence = "";					//Use Nullable sequence			foreach ($this->ParseFasta_Codon->getCodonHash() as $tempCodon=>$tempCount) {				$nullableSequence .= $tempCodon.":".$tempCount.";";			}						//if ($nullableSequence == "") 			//If input is empty			//{ $nullableSequence = null; }			//Just save null instead			$this->getCurrentJob()->setIc_frequency( $nullableSequence );		}		{	//If no CC frequency save null instead of empty string			$nullableSequence = "";					//Use Nullable sequence			foreach ($this->ParseFasta_CodonPair->getCodonHash() as $tempCodon=>$tempCount) {				$nullableSequence .= $tempCodon.":".$tempCount.";";			}			//if ($nullableSequence == "") 			//If input is empty			//{ $nullableSequence = null; }			//Just save null instead			$this->getCurrentJob()->setCc_frequency( $nullableSequence );		}		$this->getCurrentJob()->setUse_custom_species( true );	//Using Custom Species				//Update Job		CodonOpt_DAO_user_jobs::update($this->getCurrentJob());			header("Location: setup_optimization.php?".$this->getEncryptIDGetKey()."=".$this->getCurrentJob()->getEncrypt_id());		exit;		//Go back to setup optimization	}}?>